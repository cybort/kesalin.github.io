<p>&mdash;layout: posttitle: &ldquo;Elastos 开发指南&#8221;date: 2014-12-25 11:23:34 +0800comments: truecategories: [软件开发]tags: [Elastos]description: Elastos开发指南keywords: Elastos&mdash;<span id="catalog"></span>## 目录<em> <a href="#preface">前言</a></em> <a href="#codingguide">编码规范</a>    * <a href="#traslaterules">转译规则</a><em> <a href="#car">Car</a>    * <a href="#carfunction">Car 函数命名约束</a>    * <a href="#carparam">Car 函数参数命名约束</a>    * <a href="#carconstvar">Car 常量命名约束</a>    * <a href="#carenum">Car 枚举命名约束</a>    * <a href="#carconstructor">构造函数</a></em> <a href="#datatype">数据类型</a>    * <a href="#arrayof">ArrayOf</a>    * <a href="#etl">ETL</a>    * <a href="#typecast">类型转换</a><em> <a href="#smartptr">智能指针</a>    * <a href="#autoptr">AutoPtr</a>    * <a href="#weakreference">弱引用</a> * <a href="#thread">多线程</a></em> <a href="#debug">调试</a>    * <a href="#crashlocation">定位 crash</a>    * <a href="#memleaklocation">定位内存泄漏</a><em> <a href="#exception">异常</a></em> <a href="#others">其他</a><em> <a href="#qa">Q/A</a><span id="preface"></span>## 前言本文档记载有关 Car 及常用类的使用与约束，以及开发过程中碰到的疑难杂症等等问题。Elastos 实现思路是用 C++/Car 改写 Android Java Framework 层，为了减少不必要的 Bug，在改写的过程中应当尽量保持与 Android 代码的一致。但由于资源或其他方面的考虑，改写过程中总有一些与 Android 代码不一致的地方，也在此一并做一些记录说明。本文档使用 <a href="http://wowubuntu.com/markdown/">Markdown</a> 编写而成。<!--more--><span id="codingguide"></span>## 编码规范<span id="traslaterules"></span>### 转译规则1. Java 函数返回 this 的情况      若 Java 函数 return this，则对应的 Car 函数不需用通过 out 参数返回 this 指针。由于 Car 对象不能实现函数连调(如:a->Foo()->Bar())，因此这个 out 参数可以省略，以简化调用方代码的编写。例如以下 Java 方法:    <code>java    public ViewPropertyAnimator alphaBy(float value) {         animatePropertyBy(ALPHA, value);        return this;    }   </code>    对应的 Car 函数为:    <code>cpp    AlphaBy(        [in] Float value);   </code><span id="car"></span>## Car<span id="carfunction"></span>### Car 函数命名约束1. Car 函数不支持重载，因此如果一个 Car 接口的既有函数（包括从父接口继承而来的函数）已有某个特定名称的函数，而又需要继续添加参数个数或类型不同的重载函数，那么：  第二个重载函数要加后缀 Ex；  第三个重载函数要加后缀 Ex2；  第四个重载函数要加后缀 Ex3；  &hellip; 依次类推。      示例：      /Elastos/FrameworkDroid/Base/Core/car/graphics/Canvas.car    <code>cpp    interface ICanvas {        ClipRect(            [in] IRectF* rect,            [in] RegionOp op,            [out] Boolean* isNonEmpty);        ClipRectEx(            [in] IRect* rect,            [in] RegionOp op,            [out] Boolean* isNonEmpty);        ClipRectEx3(            [in] IRect* rect,            [out] Boolean* isNonEmpty);        ClipRectEx4(            [in] Float left,            [in] Float top,            [in] Float right,            [in] Float bottom,            [in] RegionOp op,            [out] Boolean* isNonEmpty);    }   </code>2. 由于所有的 Car 类（形式为：CXXX）都继承自 IObject 接口，而该接口中定义了如下通用方法：  Elastos/Runtime/Library/inc/car/elaobj.h    <code>cpp    IObject : public IInterface    {        virtual CARAPI Equals(            /* [in] */ IInterface *object,            /* [out] */ _ELASTOS Boolean *equals) = 0;        virtual CARAPI GetHashCode(            /* [out] */ _ELASTOS Int32 *hashCode) = 0;        virtual CARAPI ToString(            /* [out] */ _ELASTOS String *info) = 0;    };   </code>    并提供了基于地址比较，返回地址作为 HashCode 以及 ToString 返回十六进制显示的地址的默认实现。因此如果你需要自己的 Car 接口中提供这些函数的不同实现，请在自己的 Car 接口中同时提供这三个函数，而且这三个函数都不需要添加后缀。如果需要提供不是比较 IInterface 的便利比较函数，这些便利函数的命名遵循前一条款中的命名约束。    示例：      /Elastos/FrameworkDroid/Base/Core/car/graphics/Point.car    <code>cpp    interface IPoint {        EqualsEx2(            [in] Int32 x,            [in] Int32 y,            [out] Boolean* result);        EqualsEx(            [in] IPoint* p,            [out] Boolean* result);        Equals(            [in] IInterface* obj,            [out] Boolean* isEqual);        GetHashCode(            [out] Int32* hash);        ToString(            [out] String* info);    }   </code><span id="carparam"></span>### Car 函数参数命名约束1. Car 关键字不能用作参数名。比如：<strong>in，out，callback，callee</strong> 等等。2. Car 接口中不能出现两个同名，参数个数，参数名称，参数顺序都一样，仅参数类型不一样的 Car 函数。这是为了在<a href="http://en.wikipedia.org/wiki/Name_mangling">命名重整（name mangling）</a> 时能兼容没有类型概念的动态语言，如：Javascript。这一点尤其体现在 Car 构造函数 <strong>constructor</strong> 上，因为 Car 构造函数必定是同名的，只可能是 <strong>constructor</strong>，此时，只能通过采用不同的参数名字来区分。    示例：      /Elastos/LibCore/src/Elastos/Security/Elastos.Security.car    <code>cpp    class CPKIXBuilderParameters {        constructor();        constructor(            [in] ISet* trustAnchors,            [in] ICertSelector* targetConstraints);        constructor(            [in] IKeyStore* keyStore,            [in] ICertSelector* targetConstraints);        interface IPKIXBuilderParameters;    }   </code>3. Widget 类的 Car 构造函数 <strong>constructor</strong> 的参数命名有特殊的规则，为了支持从 xml 中解析出来 Widget 类名称创建对应的 Widget（即支持 Reflection），所有实现 IView/IActionProvider 接口的 Car 类的构造函数 <strong>constructor</strong> 的第一个参数若为 IContext* 类型则参数名称为 ctx；第二个参数若为 IAttributeSet* 类型则参数名称为 attrs。    示例：      /Elastos/FrameworkDroid/Base/Core/car/widget.car    <code>cpp    class CView {        constructor(            [in] IContext* ctx);        constructor(            [in] IContext* ctx,            [in] IAttributeSet* attrs);        constructor(            [in] IContext* ctx,            [in] IAttributeSet* attrs,            [in] Int32 defStyle);        interface IView;        interface IDrawableCallback;        interface IKeyEventCallback;        interface IAccessibilityEventSource;    }   </code><span id="carconstvar"></span>### Car 常量命名约束1. Car 中可以定义 const Int32 和 const String 常量，这些常量名字请大写，若名字中包含多个单词，请用下划线连接起来。2. 为了减少与 C++ 宏名字或全局变量名称的冲突，请不要使用那些简单过于抽象的名字，如：MAX，ID，IP 等。<span id="carenum"></span>### Car 枚举命名约束1. 枚举成员的名字均为大写，并以该枚举的名字大写为前缀，若名字中包含多个单词，请用下划线连接起来。2. 为了减少与 C++ 宏名字或全局变量名称的冲突，请不要使用那些简单过于抽象的名字，如：MAX，ID，IP 等。<span id="carconstructor"></span>### 构造函数1. 对于一个 Car 类 CXXX 来说，它有两种构造函数：C++ 构造函数 CXXX() 和 Car 构造函数 constrctor()。这两种构造函数有些类似：      * 如果没有提供自定义的实现则都会提供一个默认的无参的实现；    * 都支持构造函数重载；    但又有很大的不同：    * C++ 构造函数支持初始化列表，而 Car 构造函数不支持；    * 在 C++ 构造函数执行时，该对象还未就绪，而 Car 构造函数执行时，对象已经就绪；    利用以上事实，我们可以利用 C++ 构造函数的初始化列表初始化成员变量。2. 对于实现了 IParcelble 接口的 Car 类来说，它必须有一个可调用的无参的 Car 构造函数 constrctor（无论是默认提供的，还是显式提供的）。这是为了支持 unmarshall，即 unmarshall 时，先调用这个无参的 Car 构造函数创建对象，然后再转型为 IParcelble，调用 IParcelble::ReadFromParcel() 来设置对象的成员。因此统一规定，凡是实现了 IParcelable 的 Car 类都必须显式提供一个无参的 Car 构造函数。    示例：    /Elastos/FrameworkDroid/Base/Core/car/accounts.car    <code>cpp    class CAccount {        constructor();        constructor(            [in] String name,            [in] String type);        interface IAccount;        interface IParcelable;    }   </code><span id="datatype"></span>## 数据类型<span id="arrayof"></span>### ArrayOf1. 简介      ArrayOf 实现了类似数组的功能，即在一块连续的内存中分配若干个元素。同时 ArrayOf 能对 Car 对象指针，继承自 ElRefBase/ElLightRefBase 类的对象指针以及 String 进行自动应用计数管理（前提是通过 <strong>Set(Int32 index, T const other)</strong> 设置元素。    ArrayOf 自身实现了引用计数，因此通常情况下，它都是与 AutoPtr 结合在一起使用的。    ArrayOf 源码定义在 /Elastos/Runtime/Library/inc/eltypes/elquintet.h 中。2. 引用计数说明      引起 ArrayOf 引用计数变化的成员方法可以分为三组:    * 创建操作(<strong>Alloc/Clone</strong>)：      创建或克隆一个新对象，并且引用计数为 0（即还没有引入引用计数机制），返回的新对象需要加入 AutoPtr 自动释放或手动调用 Free/Release 释放；    * 减少引用计数操作(<strong>Release/Free</strong>)：      Release/Free 这两个接口完全等价，出于一致性考虑请使用 Release()，或加入 AutoPtr 由 AutoPtr 在内部调用 Release 自动减少引用计数，并在恰当的时候释放分配的内存；    * 增加引用计数(<strong>AddRef</strong>)：      将一个 ArrayOf 指针赋值给一个 <strong>AutoPtr</strong> 变量就是调用 <strong>AddRef</strong> 来增加引用计数的。如果需要手动增加引用计数，通常使用宏 <strong>INTERFACE_ADDREF(array)</strong> 来实现。3. 注意事项    * 对于能放入其中的元素，请考虑是否需要对元素进行引用计数管理，若需要请让该元素能够支持引用计数，然后调用 <strong>Set(Int32 index, T const other)</strong> 设置元素。简单地通过下标索引器 [] 赋值并不会自动进行引用计数管理。    * ArrayOf 会调用 memset 将分配到的内存清零，因此 ArrayOf 只能存放基本数据类型，<a href="http://zh.wikipedia.org/wiki/POD_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">POD 对象</a>)以及指针，而无法存放带有虚函数或用自定义构造函数进行初始化的对象，因为它不会调用构造函数初始化其元素，而是简单地将内存清零。    * ArrayOf 支持分配 0 个元素，即支持 ArrayOf<T>::Alloc(0); 这种用法，这对减少 NULL 判断，简化代码大有好处。    * 对于能够适用于 AutoPtr<T> 的类型 T，该类型的指针就能直接作为 ArrayOf 的元素类型，即能够使用 ArrayOf<T *> 的形式，而不需要使用 ArrayOf&lt; AutoPtr<T> > 的形式。因此，不应该出现 ArrayOf&lt; AutoPtr<T> > 形式的代码。4. 典型使用场景     * 一般场景        <code>cpp        // ThreadGroup.cpp        AutoPtr&lt;ArrayOf&lt;IThread *&gt; &gt; newThreads;        newThreads = ArrayOf&lt;IThread *&gt;::Alloc(mNumThreads * 2);        newThreads-&gt;Copy(mChildrenThreads, 0, mNumThreads);        newThreads-&gt;Set(mNumThreads++, thread);        mChildrenThreads = newThreads;       </code>     * 作为 Car 函数的 out, callee 参数          <code>cpp        // IPackageInfo.car        interface IPackageInfo {            GetActivities(                [out, callee] ArrayOf&lt;IActivityInfo*&gt;* activities);        }        // CPackageInfo.h        CarClass(CPackageInfo) {            CARAPI GetActivities(                /* [out, callee] */ ArrayOf&lt;IActivityInfo*&gt;** activities);        }        // CPackageInfo.cpp        ECode CPackageInfo::GetActivities(            /* [out, callee] */ ArrayOf&lt;IActivityInfo*&gt;** activities) {            VALIDATE_NOT_NULL(activities);            *activities = mActivities;            INTERFACE_ADDREF(*activities);            return NOERROR;        }        // 调用方        AutoPtr&lt;IPackageInfo&gt; info;        ...        AutoPtr&lt; ArrayOf&lt;IActivityInfo*&gt; &gt; activities;        info-&gt;GetActivities((ArrayOf&lt;IActivityInfo*&gt; **)&amp;activities);       </code>    * 作为函数返回值        <code>cpp        // CHardwareCamera.h        AutoPtr&lt;ArrayOf&lt;IInteger32*&gt; &gt; SplitInt(            /* [in] */ const String&amp; str);       </code>5. 双重数组  对于双重数组，请使用 Auto&lt;ArrayOf&lt;AutoPtr&lt;ArrayOf<T> > > > 形式。为了简化代码的编写，有两种办法，这两种办法都实现在 elquintent.h 文件中：    * 使用模板类。优点:通用性好。缺点:可读性不好。        <code>cpp        // 定义：elquintent.h        template &lt;typename T&gt; class ArrayOf2 {        public:            typedef AutoPtr&lt;ArrayOf&lt;T&gt; &gt; ElementType;            typedef ArrayOf&lt;ElementType&gt; Type;        }       </code>    * 使用预定义的 typedef。优点:可读性好。缺点:不能通用。        <code>cpp        // 定义：elquintent.h        typedef AutoPtr&lt;ArrayOf&lt;Byte&gt; &gt;     ByteArray;        typedef AutoPtr&lt;ArrayOf&lt;Char32&gt; &gt;   Char32Array;        typedef AutoPtr&lt;ArrayOf&lt;String&gt; &gt;   StringArray;        typedef AutoPtr&lt;ArrayOf&lt;Int32&gt; &gt;    Int32Array;        typedef AutoPtr&lt;ArrayOf&lt;Int64&gt; &gt;    Int64Array;        typedef AutoPtr&lt;ArrayOf&lt;Float&gt; &gt;    FloatArray;        typedef AutoPtr&lt;ArrayOf&lt;Double&gt; &gt;   DoubleArray;        // 使用：View.h        static const AutoPtr&lt;ArrayOf&lt;Int32Array&gt; &gt; VIEW_STATE_SETS;       </code><span id="etl"></span>### ETL1. 简介      ETL 是基于 SGI 实现的一套 C++ 模版库，它的使用方法与 STL 相似。    在使用 ETL 之前需要预设一些宏，这些宏在 #include &lt;cmdef.h>(Libcore 下)/ #include &lt;ext/frameworkdef.h> (Framework 下) 中有定义，所以在 include 任何 ETL 容器头文件之前，务必先 include 这两个头文件之一。2. 引用计数说明      ETL 中的容器自身都添加了引用计数功能，因此可以使用 AutoPtr 包装它们，如：AutoPtr&lt; List<Int32> >。但 ETL 容器并不会修改放置在它里面的元素的引用计数，这一点与 STL 的行为是一致的。3. 注意事项      要特别留意在使用 Iterator/ReverseIterator 遍历的过程中修改迭代器的情况，常见的情形就是遍历过程中调用 Erase 修改迭代器使得当前迭代器失效（请参考<a href="http://book.douban.com/subject/1243751/">Effective STL</a>）。下面将介绍各种容器分别在正向和反向遍历过程中 Erase 元素的正确使用方法。    * 对于正向迭代器 Iterator 来说，List 和 HashMap 各有不同。        List 的 Erase 返回下一个迭代器，所以使用 it = Erase(it) 即可；而 HashMap 的 Erase 返回 void，所以需要生成当前迭代器的副本，然后递增当前迭代器，再 Erase 副本，这个顺序一定不能错。又因为 HashMap 重载的后缀++操作符是先创建副本，然后递增迭代器，然后返回副本，所以可以使用 map.Erase(mit++) 简化代码。          List 使用示例:        <code>cpp        List&lt;Int32&gt;::Iterator it;        for (it = list.Begin(); it != list.End();) {            if (0 == (*it)%2) {                it = list.Erase(it);            }            else {                ++it;            }        }       </code>        HashMap 使用示例:          <code>cpp        HashMap&lt;Int32, Int32&gt;::Iterator mit;        for (mit = map.Begin(); mit != map.End();) {            if (0 == mit-&gt;mFirst % 2) {                map.Erase(mit++);            }            else {                ++mit;            }        }       </code>    * 对于反向迭代器，HashMap 没有反向迭代器，就只有 List 一种情形。由于反向迭代器是由后往前和正向迭代器相差一个元素，而 Erase 只接收正向迭代器，因此需要将反向迭代器转换为正向迭代器，情况更加复杂。首先要获得合适的正向迭代器，所以需要 &ndash;(rit.GetBase()) 获得需要删除元素的正向迭代器，然后调用 Erase 删除该元素。然后将 Erase 返回的正向迭代器。        List 使用示例:           <code>cpp        List&lt;Int32&gt;::ReverseIterator rit;        for (rit = list.RBegin(); rit != list.REnd();) {            if(0 == (*rit) % 2) {                rit = List&lt;Int32&gt;::ReverseIterator(list.Erase(--(rit.GetBase())));            }            else {                ++rit;            }        }       </code>    * 对 Erase 的用法 HashSet 与 HashMap 相同，Vector 用 Iterator 进行 Erase 与 List 相同，但 ReverseIterator 与 List 略有不同，因为 Vector 删除一个元素之后会进行内存拷贝，所以所删元素之后的迭代器均会失效，但 Vector 与 List 用 ReverseIterator 进行 Erase 可以统一到一个形式中去，所以统一下用法如下:        * 使用 List/Vector 的正向迭代器 Iterator 遍历删除。               <code>cpp            List&lt;Int32&gt;::Iterator lit;            ...            lit = list.Erase(lit);            Vector&lt;Int32&gt;::Iterator vit;            ...            vit = vector.Erase(vit);           </code>        * 使用 List/Vector 的反向迭代器 ReverseIterator 遍历删除。              <code>cpp            List&lt;Int32&gt;::ReverseIterator lrit;            ...            lrit = List&lt;Int32&gt;::ReverseIterator(list.Erase(--(lrit.GetBase())));            Vector&lt;Int32&gt;::ReverseIterator vrit;            ...            vrit = Vector&lt;Int32&gt;::ReverseIterator(vector.Erase(--(vrit.GetBase())));           </code>       * 使用 HashMap/HashSet 的正向迭代器 Iterator 遍历删除。              <code>cpp            HashMap&lt;Int32, Int32&gt;::Iterator mit;            ...            map.Erase(mit++);            HashSet&lt;Int32&gt;::Iterator sit;            ...            set.Erase(sit++);           </code>4. 错误用法      下面是用正向迭代器进行反向遍历的错误代码，请留意:    <code>cpp    List&lt;Int32&gt;::Iterator it = list-&gt;End() - 1;    for (; it != list-&gt;Begin(); it--) {        if (...) {            list-&gt;Erase(it);        }    }   </code>    这是一种错误的用法，请使用反向迭代器 ReverseIterator 进行遍历。5. 其他容器      * 由于 ETL 不能作为参数用在 Car 函数中，所以需要有 Car 接口容器类，当前代码中使用到 IArray，IObjectContainer，IObjectInt32Map，IObjectStringMap 等几个主要的 Car 接口容器类。        IObjectContainer 用法示例：        <code>cpp        AutoPtr&lt;IProviderInfo&gt; provider;        ...        AutoPtr&lt;IObjectContainer&gt; providers;        CObjectContainer::New((IObjectContainer**)&amp;providers);        providers-&gt;Add(provider);        ...        Boolean hasNext = FALSE;        AutoPtr&lt;IObjectEnumerator&gt; enumerator;        providers-&gt;GetObjectEnumerator((IObjectEnumerator**)&amp;enumerator);        while(enumerator-&gt;MoveNext(&amp;hasNext), hasNext) {            AutoPtr&lt;IInterface&gt; obj;            enumerator-&gt;Current((IInterface**)&amp; obj);            IProviderInfo * info = IProviderInfo::Probe(obj);            ...        }       </code>        <strong>注意：</strong>          在上面的 while 循环中，AutoPtr<IInterface> obj; 是声明在 while 循环体内的，而不是放在 while 循环体外。要小心 Car 指针变量作为 out 参数在循环中的多次使用，这很容易导致内存泄漏，在循环使用之前需要显式地调用 obj = NULL; 以清除上一次存储的内容。    * IList，IMap，ICollection，ISet 等 Car 容器类是与 Android 中的容器类一一对应的，将来会用这些容器类替代上面提到的 IObjectContainer，IObjectInt32Map，IObjectStringMap 等容器类。<span id="typecast"></span>### 类型转换<span id="smartptr"></span>## 智能指针1. <strong>AutoPtr</strong>  <span id="autoptr"></span>      Elastos 中的 AutoPtr 类似于 STL 中的 shared_ptr 或 Android 中的 sp。    * 使用 AutoPtr 作为返回值              通常不推荐返回 C++ 裸指针，因为这需要额外多考察去判断由谁来释放这个 C++ 指针。一般都使用 AutoPtr 来包装要返回的指针。            示例：              <code>       // CSoftKeyboardView.h        AutoPtr&lt;ISoftKeyboard&gt; GetSoftKeyboard();       </code>            在调用返回 AutoPtr 的函数时，为避免返回指针所指的对象可能被提前释放。统一规定使用 AutoPtr 来接收返回值。          推荐用法：        <code>       // CSoftKeyboardView.cpp        ECode CSoftKeyboardView::GetSoftKeyboard(            /* [out] */ ISoftKeyboard** keyboard)        {            VALIDATE_NOT_NULL(keyboard);            AutoPtr&lt;ISoftKeyboard&gt; temp = SoftKeyboardView::GetSoftKeyboard();            *keyboard = temp;            INTERFACE_ADDREF(*keyboard);            return NOERROR;        }       </code>        不推荐：            <code>       ECode CSoftKeyboardView::GetSoftKeyboard(            /* [out] */ ISoftKeyboard** keyboard)        {            VALIDATE_NOT_NULL(keyboard);            *keyboard = SoftKeyboardView::GetSoftKeyboard();            // return ptr may be released already!            INTERFACE_ADDREF(*keyboard);            return NOERROR;        }       </code>    * 在循环中使用 AutoPtr 作为 out 参数      要小心 Car 指针变量作为 out 参数在循环中的多次使用，这很容易导致内存泄漏，在循环使用之前需要显式地调用 obj = NULL; 以清除上一次存储的内容。或将变量的生命周期限定在循环体内。                正确用法：                <code>       while (...) {            AutoPtr&lt;IInterface&gt; obj;            GetObject((IInterface**)&amp;obj);        ...            }        // or        AutoPtr&lt;IInterface&gt; obj;        while (...) {            obj = NULL;            GetObject((IInterface**)&amp;obj);            ...        }       </code>        错误用法：                <code>       // or        AutoPtr&lt;IInterface&gt; obj;        while (...) {            GetObject((IInterface**)&amp;obj); // memory leak!            ...        }       </code>2. <strong>弱引用</strong>  <span id="weakreference"></span>      为了避免强引用导致的循环引用，Car 中引入了弱引用（IWeakReference/IWeakReferenceSource）的概念。Car 中的弱引用是基于 ElRefBase 实现的，详细代码情参考 elrefbase.h/elrefbase.cpp。        * Car 类实现弱引用          若 Car 类需要实现该功能，请在 sources 编译脚本中添加如下 flag 以开启 Car 编译器自动生成弱引用代码功能。                <code>       CAR_FLAGS += -u        LUBE_FLAGS += -n -u       </code>            Elastos.Droid.Core/Elastos.Droid.Server 已经开启了该功能。    * C++ 类实现弱引用        若某个 C++ 类需要提供弱引用功能，那么它需要继承 IWeakReferenceSource 接口，并实现其中的方法：                <code>       CARAPI GetWeakReference(            /* [out] */ IWeakReference** weakReference);       </code>                示例：              <code>       // app/LoadedPkg.h        class LoadedPkg            : public ElRefBase            , public IWeakReferenceSource        {        public:            CARAPI GetWeakReference(            /* [out] */ IWeakReference** weakReference);        };                // app/LoadedPkg.cpp        ECode LoadedPkg::GetWeakReference(            /* [out] */ IWeakReference** weakReference)        {            VALIDATE_NOT_NULL(weakReference)            *weakReference = new WeakReferenceImpl(this, CreateWeak(this));            INTERFACE_ADDREF(*weakReference)            return NOERROR;        }                // 使用        AutoPtr&lt;IWeakReference&gt; mWeakRef;        ...        // initialize mWeakRef        loadedPkg-&gt;GetWeakReference((IWeakReference**)&amp;mWeakRef);        ...                // use mWeakRef        AutoPtr&lt;IInterface&gt; strongObj;        mWeakRef-&gt;Resolve(EIID_IInterface, (IInterface**)&amp;strongObj);        if (strongObj != NULL) {            // strongObj is still alive!            LoadedPkg* loadedPkg = (LoadedPkg*)strongObj.Get();            ...        }               </code><span id="thread"></span>## 多线程1. 继承 IThread，IRunnable，IHandler      IThread，IRunnable，IHandler 都有标准的父类，应该优先通过继承这些父类来实现子类的功能。    * IThread 的父类为 Elastos::Core::Threading::ThreadBase    * IRunnable 的父类为 Elastos::Droid::Os::Runnable    * IHandler  的父类为 Elastos::Droid::Os::HandlerBase    * 此外 Elastos::Droid::Os::HandlerRunableBase 同时实现了 IHandler 与 IRunnable 接口。2. 锁      有两种方式来使用锁：Elastos::Core::Threading::Metux 与 Elastos::Core::Threading::Object，两者均提供了 Autolock 的便利设施。Object 还具备 Wait/Notify 功能。3. 设置 IMessage 的 obj 参数      如果需要将自定义数据类型设置为 IMessage 的 obj 参数，那么该参数必须继承自 IInterface，通常我们会通过如下模式的代码来使用：    <code>cpp    // 参数类型    class SomeArgs        : public ElRefBase        , public IInterface    {    public:        CAR_INTERFACE_DECL()        ...    };    // 发送消息    AutoPtr&lt;SomeArgs&gt; args = SomeArgs::Obtain();    AutoPtr&lt;IMessage&gt; msg;    mHandler-&gt;ObtainMessageEx(MSG_RESIZED_REPORT, args, (IMessage**)&amp;msg);    Boolean result;    mHandler-&gt;SendMessage(msg, &amp;result);    // 处理消息    AutoPtr&lt;IInterface&gt; obj;    msg-&gt;GetObj((IInterface**)&amp;obj);    ...    case ViewRootImpl::MSG_RESIZED_REPORT: {        AutoPtr&lt;SomeArgs&gt; args = (SomeArgs*)obj.Get();        ...        args-&gt;Recycle();    }   </code>    Elastos::Droid::Os::SomeArgs 是能够存储多个 IInterface/Int32 类型的参数 wrapper 类，并提供了参数池机制，该类已经导出，可以在代码中自由使用。    一些 Wigdet 接口提供了 SetTag/GetTag 函数，这个 tag 参数的设置也请参照上面 IMessage 的 obj 参数设置示例。5. syn(this) 的翻译<span id="debug"></span>## 调试<span id="crashlocation"></span>### 定位 crashElastos 的 eco 支持根据 logcat 中程序 crash 的地址定位到源码中具体的位置。主要步骤如下:1. 在需要定位的 eco 的编译目录中的 sources 文件里加入<code>EXPORT_ALL_SYMBOLS = 1</code> (位置最好放到<code>TARGET_TYPE = eco</code>声明后面)。2. 随便修改目录下的某个.cpp文件，或者 touch 一下某个.cpp文件(目的是使得接下来 emake 操作时能重新链接)，然后调用 emake。3. 执行<code>pd @</code>，然后执行<code>elcopy xxx.eco /system/lib/</code>将 eco 拷贝到相应目录下(大多是<code>/system/lib</code>)，然后执行程序。4. 当程序 crash 时，logcat 会 dump 出 crash 进程的信息。其中<code>backtrace:</code>栏目下会打出 crash 时的调用栈如下：    <code>html    backtrace:    I/DEBUG   ( 1218):     #01  pc 013624a4  /system/lib/Elastos.Droid.Core.eco    I/DEBUG   ( 1218):     #02  pc 0134e328  /system/lib/Elastos.Droid.Core.eco    I/DEBUG   ( 1218):     #03  pc 0134e49c  /system/lib/Elastos.Droid.Core.eco    ...   </code>    其中，013624a4 是出错地址，0134e328 和 0134e49c 是调用者的函数栈展开。5. 取得 crash 地址后，再<code>pd @</code>后的 target 目录下,然后<code>cd debug_info</code>到下面的<code>dbg_info</code>子目录下，然后执行：    <code>   arm-linux-androideabi-addr2line –e XXX.eco crash-address   </code>    就可以定位到源码中出错的具体位置。    比如，针对例子中的地址，执行：    <code>   arm-linux-androideabi-addr2line -e Elastos.Droid.Core.eco 013624a4   </code>    会得到以下结果:        <code>   /home/kesalin/ElastosRDK4_2_2/Targets/obj/rdk/arm.gnu.android.dbg/inc/elautoptr.h:112   </code>方便调试的便利脚本：（感谢饶雪提供）  * 为了方便将多个地址信息批量转换为源码中的位置信息，饶雪写了一个便利脚本，内容如下：        <code>shell    #!/bin/bash    cut $1 -d ' ' -f 13-15 &gt; tempx8x9    while read line    do        echo $line    done &lt; tempx8x9    while read line    do        #echo $line        NUM=`echo $line | cut -d ' ' -f 1`        #echo $NUM        F=`echo $line | cut -d ' ' -f 2 | cut -d '/' -f 4`        #echo $F        arm-linux-androideabi-addr2line -e ~/ElastosRDK4_2_2/Targets/rdk/arm.gnu.android.dbg/bin/dbg_info/$F $NUM    done &lt; tempx8x9    rm tempx8x9   </code>    注意：这个脚本只针对 dbg 版本，如果需要定位 rls 版本则需要修改脚本中的路径。</em> 该脚本已经放入<code>ElastosRDK4_2_2/DevDoc/DbgTools/addr2line_dbg.sh</code>中。使用时，进入到 <code>ElastosRDK4_2_2/DevDoc/DbgTools</code>目录下，如果将 crash 信息拷贝到 crashinfo 文档内，其格式如下：        <code>   I/DEBUG   ( 1218):     #01  pc 013624a4  /system/lib/Elastos.Droid.Core.eco    I/DEBUG   ( 1218):     #02  pc 0134e328  /system/lib/Elastos.Droid.Core.eco    I/DEBUG   ( 1218):     #03  pc 0134e49c  /system/lib/Elastos.Droid.Core.eco   </code>        然后执行如下命令<code>./debug.sh crashinfo</code>，就能得到        <code>   ~/ElastosRDK4_2_2/DevDoc/DbgTools$./addr2line_dbg.sh crashinfo     013624a4 /system/lib/Elastos.Droid.Core.eco    0134e328 /system/lib/Elastos.Droid.Core.eco    0134e49c /system/lib/Elastos.Droid.Core.eco    /home/kesalin/ElastosRDK4_2_2/Targets/obj/rdk/arm.gnu.android.dbg/inc/elautoptr.h:112    /home/kesalin/ElastosRDK4_2_2/Sources/Elastos/Frameworks/Droid/Base/Core/src/view/CInputDevice.cpp:365    /home/kesalin/ElastosRDK4_2_2/Sources/Elastos/Frameworks/Droid/Base/Core/src/view/CInputDevice.cpp:386   </code><span id="memleaklocation"></span>### 定位内存泄漏<span id="exception"></span>## 异常<span id="others"></span>## 其他<span id="qa"></span>## Q/A</p>
